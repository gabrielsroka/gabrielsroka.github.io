<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Misty Programming Language: Security</title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>
    <div class=mistyhead><a href="https://www.crockford.com/misty">Misty Programming Language:</a></div>
    <h1>Security</h1>
<p>Conventional programming languages give too much power to programs. Typically,
  any program is potentially capable of doing anything that the whole system
  is capable of doing. This makes sense to programmers because programmers
  want powerful tools. But it shouldn't make sense for anyone else because
  such inappropriately powerful systems are unable to adequately defend
  themselves against malicious or imprudent programs. Attempts to add security
  features to existing systems have proven to be sadly and painfully and
  expensively ineffective. Archaic measures like file permissions are based
  on the assumption that individuals are responsible for the security properties
  of the programs they run. Security management software which alerts the
  user to potentially dangerous actions are worse than ineffective: Most
  people cannot possibly be expected to know how to correctly respond to
  those interruptions. Ineffective security measures at best allow us to
  blame the victim, particularly when the fault lies not with the victim
  but with insecure system designs. </p>
<p>Misty takes a different approach. Instead of attempting to add security,
  it makes it possible to remove sources of insecurity. It does this by
  giving each actor or function in an application just the resources it needs in order
  to do its work and no more. The potential amount of intentional or unintentional
  mischief is substantially reduced. It is as if there is a firewall around
  every single object in the application. Misty does this while introducing
  no additional run-time overhead.</p>
<p>Misty is able to do this because it is an Object-Capability System. Secrets
  and powerful actions can be hidden behind objects that will properly control
  access. This is object-oriented security.</p>
<p>In an Object-Capability System, there are exactly three ways in which to obtain
  an object reference:</p>
<ol>
  <li>By Creation. When an object is made, it may be endowed by its creator with
    references.</li>
  <li>By Construction. A request to construct an object will return a reference
    to that object.</li>
  <li>By Introduction. Invocations can carry object references. References
    can only be passed directly from an entity to entities of its immediate
    acquaintance.</li>
</ol>
<p>No other means are possible. References cannot be obtained by simply
  knowing the name of something (such as <code>'root'</code>), or by pointer-arithmetic,
  or from global variables or public class variables. With this level of
  object containment, if two pieces of hostile code are loaded in the same
  process, they will not be able to call each other or exchange object references
  without there first being an introduction.</p>
<p>With such containment, object references become tokens of authority. If a function
  has a reference to an object, then it has the authority to interact with that
  object. </p>
<h4><code>stone</code></h4>
<p>The <code>stone</code> function makes an object immutable.</p>
<p>The <code>stone</code> function has no effect on values that are already
  immutable.</p>
<h2>Records</h2>
<p>Record  references should always be stoned before they are passed through
  a trust boundary. A stoned record allows read-only access to its data members,
  and invocation of its functions.</p>
<p>Getting a value from an object or setting a value on an object never
  causes a transfer of control except when failure occurs</p>
<h2>Functions</h2>
<p>Functions are first class immutable values and can be stored in and retrieved
  from objects.</p>
<h2>Lambda</h2>
<p>Misty functions are <a href="http://www.crockford.com/javascript/little.html">lambdas</a>.
  They bind context with a specific set of parameters and statements. This
  binding (or closure) provides mechanisms for creating private variables.
  Functions only have access to the values they are bound to.</p>
<h2>Facets</h2>
<p>A facet is an object or function that acts as an intermediary. A facet
  can provide a limited interface to a more powerful object or function.
  A facet can filter, check, and validate requests. For example, a file
  system facet might permit access to only certain directories, or prevent
  files from growing beyond a certain size. The facet object looks to the
  application like a file system object, but the operations it permits are
  limited. </p>
<p>Facets can also be used to provide revocability. A facet can be ordered by
  its issuer to become inert, which effectively prevents the application from
  making further use of it. A facet can also be constructed to work only once
  and then become inert.</p>
<h1>Latent Properties</h1>
<p>Records can use other records as property keys. Since records are capabilities,
  latent properties can be accessed only when holding both the record and
  the key.</p>
<pre>def latent: {}        # hold the undiscoverable key


my_object[latent]     # using the key
</pre>
<h2>Environment</h2>
<p>The security of the Misty language depends on the security of the run-time
  environment. The interfaces that are provided should practice Capability
  Discipline.</p>
</body></html>
